var testShader = [
  'uniform float time;',
  'uniform float noiseStep;',
  'uniform float uvScale;',
  'float hash2d(vec2 p) {',
  '    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));',
  '    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );',
  '}',
  'float noise2d( in vec2 p ) {',
  '    vec2 i = floor( p );',
  '    vec2 f = fract( p );',
  '  ',
  '  vec2 u = f*f*(3.0-2.0*f);',
  '    return mix( mix( hash2d( i + vec2(0.0,0.0) ), ',
  '                    hash2d( i + vec2(1.0,0.0) ), u.x),',
  '                mix( hash2d( i + vec2(0.0,1.0) ), ',
  '                    hash2d( i + vec2(1.0,1.0) ), u.x), u.y);',
  '}',
  ' float hash3d(vec3 p) {',
  '     p  = fract( p*0.3183099+.1 );',
  '     p *= 17.0;',
  '     return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );',
  ' }',

  'float noise3d( in vec3 x ) {',
  '    vec3 p = floor(x);',
  '    vec3 f = fract(x);',
  '    f = f*f*(3.0-2.0*f);',
  '  ',
  '    return mix(mix(mix( hash3d(p+vec3(0,0,0)), ',
  '                        hash3d(p+vec3(1,0,0)),f.x),',
  '                  mix( hash3d(p+vec3(0,1,0)), ',
  '                        hash3d(p+vec3(1,1,0)),f.x),f.y),',
  '              mix(mix( hash3d(p+vec3(0,0,1)), ',
  '                        hash3d(p+vec3(1,0,1)),f.x),',
  '                  mix( hash3d(p+vec3(0,1,1)), ',
  '                        hash3d(p+vec3(1,1,1)),f.x),f.y),f.z);',
  '}',

  'void main() {',
  '  vec2 cellSize = 1.0 / resolution.xy;',
  '  vec2 uv = gl_FragCoord.xy * cellSize;',

  '  uv *= uvScale;',
  '  uv -= (uvScale * 0.5);',

  '  // 3D noise : ',
  ' const mat3 m33 = mat3( 0.00,  0.80,  0.60,',
  '   -0.80,  0.36, -0.48,',
  '   -0.60, -0.48,  0.64 );',
  '  float f3d = 0.0;',
  '  vec3 q = vec3(uv, time);',
  '  f3d  = 0.5000*noise3d( q ); q = m33*q*2.01;',
  '  if(noiseStep > 1.0 ) {',
  '     f3d += 0.2500*noise3d( q ); q = m33*q*2.02;',
  '  }',
  '  if(noiseStep > 2.0 ) {',
  '     f3d += 0.1250*noise3d( q ); q = m33*q*2.03;',
  '  }',
  '  if(noiseStep > 3.0 ) {',
  '     f3d += 0.0625*noise3d( q ); q = m33*q*2.01;',
  '  }',

  '  float f = f3d;',
  // '  f = 0.5 + 0.5*f;',

  '  gl_FragColor = vec4(vec3(f), 0.5);',
  '}'

].join('\n');

export default testShader;